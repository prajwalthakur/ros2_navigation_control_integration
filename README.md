# MPPI-Based Reach-Avoid Simulation integrated with NAV2 and ROS2_CONTROL Package

This repository provides a simulation framework for Model Predictive Path Integral (MPPI) control in a reach-avoid setting using ROS2, ROS2_CONTROL, NAV2 and with Gazebo integration. The simulation showcases real-time obstacle avoidance and goal-directed planning.

## Highlights: 
- Python-based simulation with Matplotlib for easy visualization and debugging

- ROS2 and Gazebo support for realistic robotic simulations with TurtleBot3

- GPU-accelerated planning (via JAX ), runs up to 20 Hz

- Modular design with configurable parameters via YAML

- Dockerized setup for consistent environments

- Can be adapted to any vehicle dynamics/kinematics equation, just need to change the dimension of control inputs, states and  ODE equation for the dynamics.

## System Requirements:

- Tested on Ubuntu 22.04 with Ryzen 7 and RTX 3050

- CUDA-enabled GPU recommended; CPU-only mode supported (See notes at the end of the readme)

<!-- ## Demo Videos:

`non_ros/example_video/`: Matplotlib-based simulation

`mppi_planner/example_video/`: ROS2 + Gazebo simulation -->

# Setup:
Assumes Cuda compatible hardware (check notes, if needs to run in cpu only)
## Docker Image Installation 
1. Install the Docker **Engine** [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)

Steps to create the Docker Image **ros2_nav** (~10 min)
1. From root of the directory  run  `./scripts/build/build.sh`


## To run the docker Conatiner

Steps to create a docker container **ros2_nav** and will run it in a intractive mode

1. From root of the directory run `./scripts/deploy/devel.sh`

To launch multiple shells in docker container **ros2_nav**, run the following
1. run `docker exec -it ros2_nav bash` . This will attach the current terminal to the docker container ros2_nav. 

## Steps to build the package

make sure you are in ros2 workspace.
1. change the directory to `root/workspace/`
2. run `colcon build --symlink-install`
3. source `install/setup.bash`


<!-- ## Steps to run the simulation in simple python and Matplotlib simulation
1. run `cd root/workspace/src/non_ros`
2. run `python3 main.py`

### Discription of files
1. `main.py` : Main script to launch mppi function and visualization script
2. `dyn_visualization.py`: Script to simulate dynamics and visualization
3. `mppi.py`: Main logic for the mppi planner
4. `config/sim_config.yaml`: Configurations related to simulations, dynamics and mppi-planner

#### Note:
1. Obstacles, start, and goal positions can be randomly generated by changing the seed in `sim_config.yaml`
2. Currently, the start and goal are deterministically set and can be modified in `main.get_start_goal`



https://github.com/user-attachments/assets/f546e0e0-457c-4443-befe-497f6370a613



# Steps to run the simulation in ROS2
After building the package, run the following launch files
1. run `ros2 launch mppi_planner mppi_planner.launch.py`  
this will run the simulation node spawn the obstacles
2. run `ros2 run mppi_planner mppi_planner_node` 
this will run the mppi_planning_node.py which contains the mppi planning logic

note: It may happen that launching Gazebo for the first time fails or some elements are not spawned. In that case, stop the process and relaunch it.

### Discription of files
```
|-- config
|   |-- mppi_rviz.rviz
|   |-- sim_config.yaml
|-- launch
|   |-- mppi_planner.launch.py
|-- mppi_planner
|   |-- mppi_class.py
|   |-- mppi_planner_node.py
|   `-- spawn_cylinder.py

```
1. `mppi_planner.launch.py` : Launch file to run the simulation node spawn the obstacles
2. `mppi_class.py`: Script to run the mppi-planning algorithm
3. `spawn_cylinder.py`: Script to spawn the obstacles, included in launch file
3. `mppi_rviz.rviz`: Rviz Configuration
4. `sim_config.yaml`: Configurations related to simulations, dynamics and mppi-planner

#### Note:
1. Obstacles, goal positions are hard coded in  `mppi_planner/config/sim_config.yaml`
2. MPPI is aware of the all the static obstacles



https://github.com/user-attachments/assets/8f08e8bb-debb-4088-8320-08d60748fde6



## TO DO:
- [] Add Unit Test Cases
- [] Implement MPPI in C++
- [] Utilize the local costmap to generate motion plans using MPPI.
- [] CVar MPPI for stochastic dynamics


## Note:
If the system doesnt support CUDA, then, in ros2_nav.Dockerfile:
- Change the base image from  `FROM  nvidia/cuda:12.6.0-cudnn-devel-ubuntu22.04` to `FROM ubuntu:22.04`
- Change the jax-cuda installation from `RUN pip3 install  "jax[cuda12]" ` to  `RUN pip3 install "jax[cpu]" -f https://storage.googleapis.com/jax-releases/jax_releases.html`
-In `deploy/devel.sh` change mode from `"gpu"` to `"cpu"` -->

## License
MIT License (Non-Commercial)







## Author
[Prajwal Thakur](https://github.com/prajwalthakur) 

