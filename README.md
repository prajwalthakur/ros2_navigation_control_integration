# ROS2 Navigation And control Package Integration

This repository demonstrates the integration of ROS2 Control, Nav2, and Gazebo for autonomous mobile robot navigation for a mapless navigation.

## Objectives
Demonstrate system-level integration capabilities in ROS 2.

### Learn to configure and use:

- ros2_control for hardware abstraction and control

- Nav2 for autonomous navigation

- costmap_2d for dynamic obstacle mapping and avoidance

## Highlights: 
- ROS2 and Gazebo support for realistic robotic simulations with a differential drive robot

- Modular design with configurable parameters via YAML

- Dockerized setup for consistent environments

- Can be adapted to any vehicle dynamics/kinematics equation, just need to change the dimension of control inputs, states and  ODE equation for the dynamics.

- Real-time obstacle avoidance

- Fully mapless operation (no prior map required)

## System Requirements:

- Tested on Ubuntu 22.04 with Ryzen 7 and RTX 3050

- CUDA-enabled GPU recommended; CPU-only mode supported (See notes at the end of the readme)

## Demo Videos:

`example_video`: mapless_navigation.mp4



https://github.com/user-attachments/assets/c65bb692-e3b2-4632-b2f7-a70809ba38fe



# Setup:
Assumes Cuda compatible hardware (check notes, if needs to run in cpu only)
## Docker Image Installation 
1. Install the Docker **Engine** [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)

Steps to create the Docker Image **ros2_nav** (~10 min)
1. From root of the directory  run  `./scripts/build/build.sh`


## To run the docker Conatiner

Steps to create a docker container **ros2_nav** and will run it in a intractive mode

1. From root of the directory run `./scripts/deploy/devel.sh`

To launch multiple shells in docker container **ros2_nav**, run the following
1. run `docker exec -it ros2_nav bash` . This will attach the current terminal to the docker container ros2_nav. 

## Steps to build the package

make sure you are in ros2 workspace.
1. change the directory to `root/workspace/`
2. run `rosdep install --from-paths src --ignore-src  -r  -y`
3. run `colcon build --symlink-install`
4. source `install/setup.bash`
5. run `ros2 launch diff_drive_control launch_sim.launch.py world:=/root/workspace/src/diff_drive/worlds/obstacles.world`
6. run `rviz2 -d /root/workspace/src/diff_drive/config/main.rviz` to launch the rviz
7. run `ros2 launch diff_drive_control navigation_launch.py` to launch the controller server, which launch the costmap to generate the 2d costmap
8. select goal pose from the rviz tool     
     



<!-- ## Steps to run the simulation in simple python and Matplotlib simulation
1. run `cd root/workspace/src/non_ros`
2. run `python3 main.py`

### Discription of files
1. `main.py` : Main script to launch mppi function and visualization script
2. `dyn_visualization.py`: Script to simulate dynamics and visualization
3. `mppi.py`: Main logic for the mppi planner
4. `config/sim_config.yaml`: Configurations related to simulations, dynamics and mppi-planner

#### Note:
1. Obstacles, start, and goal positions can be randomly generated by changing the seed in `sim_config.yaml`
2. Currently, the start and goal are deterministically set and can be modified in `main.get_start_goal`



https://github.com/user-attachments/assets/f546e0e0-457c-4443-befe-497f6370a613



# Steps to run the simulation in ROS2
After building the package, run the following launch files
1. run `ros2 launch mppi_planner mppi_planner.launch.py`  
this will run the simulation node spawn the obstacles
2. run `ros2 run mppi_planner mppi_planner_node` 
this will run the mppi_planning_node.py which contains the mppi planning logic

note: It may happen that launching Gazebo for the first time fails or some elements are not spawned. In that case, stop the process and relaunch it.

### Discription of files
```
|-- config
|   |-- mppi_rviz.rviz
|   |-- sim_config.yaml
|-- launch
|   |-- mppi_planner.launch.py
|-- mppi_planner
|   |-- mppi_class.py
|   |-- mppi_planner_node.py
|   `-- spawn_cylinder.py

```
1. `mppi_planner.launch.py` : Launch file to run the simulation node spawn the obstacles
2. `mppi_class.py`: Script to run the mppi-planning algorithm
3. `spawn_cylinder.py`: Script to spawn the obstacles, included in launch file
3. `mppi_rviz.rviz`: Rviz Configuration
4. `sim_config.yaml`: Configurations related to simulations, dynamics and mppi-planner

#### Note:
1. Obstacles, goal positions are hard coded in  `mppi_planner/config/sim_config.yaml`
2. MPPI is aware of the all the static obstacles



https://github.com/user-attachments/assets/8f08e8bb-debb-4088-8320-08d60748fde6



## TO DO:
- [] Add Unit Test Cases
- [] Implement MPPI in C++
- [] Utilize the local costmap to generate motion plans using MPPI.
- [] CVar MPPI for stochastic dynamics -->


## Note:
If the system doesnt support CUDA, then, in ros2_nav.Dockerfile:
- Change the base image from  `FROM  nvidia/cuda:12.6.0-cudnn-devel-ubuntu22.04` to `FROM ubuntu:22.04`
- Change the jax-cuda installation from `RUN pip3 install  "jax[cuda12]" ` to  `RUN pip3 install "jax[cpu]" -f https://storage.googleapis.com/jax-releases/jax_releases.html`
-In `deploy/devel.sh` change mode from `"gpu"` to `"cpu"`

### Note:
The robot description is forked from [https://github.com/joshnewans/articubot_one](https://github.com/joshnewans/articubot_one) 
## License
MIT License (Non-Commercial)







## Author
[Prajwal Thakur](https://github.com/prajwalthakur) 

